//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine ;
using System.Collections ;

using CoreFramework ;

namespace CoreFramework.Coroutines
{

/// <summary>represents a coroutine whose state can be tracked and requested to change.</summary>
public class ManagedCoroutine : ICoroutine
{ private IEnumerator _step ;
  private CoroutineState _state ;
  
  /// <summary>Initializes a new instance of the ManagedCoroutine class with the call to the
  /// yielding IEnumerator function</summary>
  /// <param name="pCoroutineCall">The referenece to the yield function
  /// that will get coroutined</param>
  public ManagedCoroutine ( IEnumerator pCoroutineCall )
  { this._step = pCoroutineCall ;
    this._state = CoroutineState.Running ;
  }
  
  /// <summary>Returns the current state of the coroutine</summary>
  /// <value>The current state of the coroutine</value>
  public CoroutineState State
  { get { return this._state ; }
    protected set { this._state = value ; }
  }

  virtual public System.Object Current
  { get { return this._step.Current ; }
  }
  
  public void Reset ( )
  { throw new System.NotSupportedException() ;
  }
  
  /// <summary>Requests the coroutine to pause.</summary>
  /// <remarks><para>If the coroutine is already paused, finished, aborted,
  /// with a pending pause request, or with a pending abort request
  /// the object does not change its state and the pause request is dimissed</para>
  /// <para>If the coroutine is running, the pause request will change the couroutine
  /// state to CoroutineState.PauseRequested immediately, and will be processed
  /// on the following frame. If the pause request succeeds on the following frame,
  /// the coroutine changes to a paused state</para>
  /// <para>A pause request will override a Continue request made previously
  /// in the same frame</para></remarks>
  public void RequestPause ( )
  { if ( this._state == CoroutineState.Running || this._state == CoroutineState.ContinueRequested )
    {
      this._state = CoroutineState.PauseRequested ;
    }
  }
  
  /// <summary>Requests the coroutine to abort.</summary>
  /// <remarks><para>An abort request is only dimissed
  /// if the couroutine has already finished</para>
  /// <para>If the coroutine is not finished,
  /// the abort request will change the coroutine's state to CoroutineState.AbortRequest immediately
  /// and will be processed on the following frame. On the following frame, the coroutine's state
  /// will get changed to aborted</para>
  /// <para>An AbortRequest will override any request made previously in the same frame,
  /// and cannot be overriden or undone.</para></remarks>
  public void RequestAbort ( )
  { if ( this._state != CoroutineState.Finished )
    {this._state = CoroutineState.AbortRequested ;
    }
  }
  
  /// <summary>Requests a paused coroutine to resume</summary>
  /// <remarks><para>A Continue request is dimissed if the couroutine is running, has finished,
  /// has been aborted, or has been requested to abort.</para>
  /// <para>A continue request will override any pause request made previously
  /// in the same frame</para>
  /// <para>When successful, a continue request will immediately change the coroutine's state to
  /// CoroutineState.ContinueResquested and the coroutine's state will be back to running
  /// on the following frame</para></remarks>
  public void RequestContinue ( )
  { if ( this._state == CoroutineState.Paused || this._state == CoroutineState.PauseRequested )
    { this._state = CoroutineState.ContinueRequested ;
    }
  }
  
  virtual public bool MoveNext ( )
  { bool aborted , paused , moveNext = false ;
  
    aborted = ( this._state == CoroutineState.AbortRequested ) ;
    
    paused = (
      this._state == CoroutineState.PauseRequested ||
      this._state == CoroutineState.Paused
    ) ;
  
    if ( aborted )
    { this._state = CoroutineState.Aborted ;
      moveNext = false ;
    }
    else if ( paused )
    { this._state = CoroutineState.Paused ;
      moveNext = true ;
    }
    else
    { moveNext = this._step.MoveNext() ;
      if ( moveNext )
      { this._state = CoroutineState.Running ;
      }
      else
      { this._state = CoroutineState.Finished ;
      }
    }
    
    return moveNext ;
  }

  /// <summary>Finishes the rest of the coroutine in the current frame</summary>
  /// <remarks><para>FinishNow() does nothing if the coroutine has already finished,
  /// has been aborted or requested to abort.</para>
  /// <para>FinishNow() overrides any pending pause request made previously</para>
  /// <para>If the coroutine is paused, FinishNow() will change it to a running state,
  /// finish it in the current frame, and then change it to the finished state</para></remarks>
  public void FinishNow ( )
  { if ( this._state == CoroutineState.Running ||
         this._state == CoroutineState.Paused ||
         this._state == CoroutineState.PauseRequested ||
         this._state == CoroutineState.ContinueRequested )    
    { this._state = CoroutineState.Running ;
      while ( this.MoveNext()) ;
      this._state = CoroutineState.Finished ;
    }
  }
  
  public bool IsPausedOrPauseRquested ( )
  { return this._state == CoroutineState.Paused || this._state == CoroutineState.PauseRequested ;
  }
  
  public bool IsAbortedOrAbortRequested ( )
  { return this._state == CoroutineState.Aborted || this._state == CoroutineState.AbortRequested ;
  }

  public bool IsRunningOrContinueRequested ( )
  { return this._state == CoroutineState.Running || this._state == CoroutineState.ContinueRequested ;
  }

  public bool IsFinishedOrAborted ( )
  { return this._state == CoroutineState.Finished || this._state == CoroutineState.Aborted ;
  }
}


public class ManagedCoroutine<ReturnType> : ManagedCoroutine , ICoroutine<ReturnType>
{ ReturnType _value ;
  
  public ManagedCoroutine ( IEnumerator pCoroutine ) : base( pCoroutine ) { }
  
  public ReturnType Value
  { get { return this._value ; }
  }
  
  override public bool MoveNext ( )
  { bool moveNext = base.MoveNext() ;
    
    if ( this.State != CoroutineState.Aborted &&
         this.Current != null &&
         this.Current is ReturnType )
    { this._value = (ReturnType)( this.Current ) ;
      moveNext = false ;
      this.State = CoroutineState.Finished ;
    }
    
    return moveNext ;
  }
}
}
